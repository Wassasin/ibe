#![no_std]

//! Identity Based Encryption Waters-Naccache scheme on the [BLS12-381 pairing-friendly elliptic curve](https://crates.io/crates/pairing).
//!  * Inspired by: [CHARM implementation](https://github.com/JHUISI/charm/blob/dev/charm/schemes/ibenc/ibenc_waters05.py)
//!  * From: "[Secure and Practical Identity-Based Encryption](http://eprint.iacr.org/2005/369.pdf)"
//!  * Published in: IET Information Security, 2007
//!
//! Uses [SHA3-256](https://crates.io/crates/tiny-keccak) for hashing to identities.

mod util;

use pairing::bls12_381::{Bls12, Fq12, Fr, FrRepr, G1, G2};
use pairing::{CurveProjective, Engine, Field, PrimeField};
use rand::{Rand, Rng};

const HASH_BIT_LEN: usize = 256;
const HASH_BYTE_LEN: usize = HASH_BIT_LEN / 8;

const BITSIZE: usize = 32;
const CHUNKSIZE: usize = BITSIZE / 8;
const CHUNKS: usize = HASH_BYTE_LEN / CHUNKSIZE;

type Parameters = [Fr; CHUNKS];

/// Public key parameters generated by the PKG used to encrypt messages.
#[derive(Clone, Copy)]
pub struct PublicKey {
    g: G1,
    g1: G1,
    g2: G2,
    uprime: G2,
    u: Parameters,
}

/// Field parameters for an identity.
///
/// Effectively a hash of an identity, mapped to the curve field.
/// Together with the public key parameters generated by the PKG forms the user public key.
#[derive(Clone, Copy)]
pub struct Identity([Fr; CHUNKS]);

/// Secret key parameter generated by the PKG used to extract user private keys.
#[derive(Clone, Copy)]
pub struct SecretKey {
    g2prime: G2,
}

/// Points on the paired curves that form the user private key.
#[derive(Clone, Copy)]
pub struct UserPrivateKey {
    d1: G2,
    d2: G1,
}

/// Encrypted message. Can only be decrypted with an user private key.
#[derive(Clone, Copy)]
pub struct CipherText {
    c1: Fq12,
    c2: G1,
    c3: G2,
}

/// A point on the paired curve that can be encrypted and decrypted. Unmarshals to a key usable in AES.
#[derive(Clone, Copy, PartialEq, Debug)]
pub struct Message(Fq12);

impl Message {
    /// Generate a random point on the paired curve.
    pub fn generate<R: Rng>(rng: &mut R) -> Self {
        Self(Fq12::rand(rng))
    }

    /// Hashes the underlying point on the curve representation to a scalar.
    pub fn marshal(&self) -> [u8; HASH_BYTE_LEN] {
        use util::Marshallable;

        let mut h = util::Sha3Write::new();
        self.0.marshal(&mut h);

        h.finalize()
    }
}

/// Generate a keypair used by the Private Key Generator (PKG).
pub fn setup<R: Rng>(l: usize, rng: &mut R) -> (PublicKey, SecretKey) {
    let h_len = HASH_BYTE_LEN * 8;
    let n = h_len / l;

    assert_eq!(CHUNKS, n);

    let g = G1::rand(rng);

    let alpha = Fr::rand(rng);
    let mut g1 = g;
    g1.mul_assign(alpha);

    let g2 = G2::rand(rng);
    let uprime = G2::rand(rng);

    let mut u = [Fr::zero(); CHUNKS];
    for ui in u.iter_mut() {
        *ui = Fr::rand(rng);
    }

    let pk = PublicKey {
        g,
        g1,
        g2,
        uprime,
        u,
    };

    let mut g2prime = g2;
    g2prime.mul_assign(alpha);

    let sk = SecretKey { g2prime };

    (pk, sk)
}

/// Extract an user private key for a given identity.
pub fn extract<R: Rng>(
    pk: &PublicKey,
    sk: &SecretKey,
    v: &Identity,
    rng: &mut R,
) -> UserPrivateKey {
    let r = Fr::rand(rng);

    let mut ucoll: G2 = pk.uprime;
    for (ui, vi) in pk.u.iter().zip(&v.0) {
        ucoll.mul_assign(ui.pow(vi.into_repr()));
    }

    ucoll.mul_assign(r.into_repr());

    let mut d1: G2 = sk.g2prime;
    d1.add_assign(&ucoll);

    let mut d2 = pk.g;
    d2.mul_assign(r);

    UserPrivateKey { d1, d2 }
}

/// Encrypt a message using the PKG public key and an identity.
pub fn encrypt<R: Rng>(pk: &PublicKey, v: &Identity, m: &Message, rng: &mut R) -> CipherText {
    let t = Fr::rand(rng);

    let mut c1 = Bls12::pairing(pk.g1, pk.g2).pow(t.into_repr());
    c1.mul_assign(&m.0);

    let mut c2 = pk.g;
    c2.mul_assign(t);

    let mut c3: G2 = pk.uprime;
    for (ui, vi) in pk.u.iter().zip(&v.0) {
        c3.mul_assign(ui.pow(vi.into_repr()));
    }

    c3.mul_assign(t.into_repr());

    CipherText { c1, c2, c3 }
}

/// Decrypt ciphertext to a message using a user private key.
pub fn decrypt(usk: &UserPrivateKey, c: &CipherText) -> Option<Message> {
    let num = Bls12::pairing(usk.d2, c.c3);
    let dem = Bls12::pairing(c.c2, usk.d1);

    let mut m = c.c1;
    m.mul_assign(&num);
    m.mul_assign(&dem.inverse()?);

    Some(Message(m))
}

impl Identity {
    /// Hash a byte slice to a set of Identity parameters, which acts as a user public key.
    /// Uses sha3-256 internally.
    pub fn derive(b: &[u8]) -> Identity {
        let hash = tiny_keccak::sha3_256(b);

        let mut result = [Fr::zero(); CHUNKS];
        for (i, chunk) in hash.chunks_exact(CHUNKS).enumerate() {
            use core::convert::TryInto;
            result[i] =
                Fr::from_repr(FrRepr::from(u64::from_be_bytes(chunk.try_into().unwrap()))).unwrap();
        }

        Identity(result)
    }

    /// Hash a string slice to a set of Identity parameters.
    /// Directly converts characters to UTF-8 byte representation.
    pub fn derive_str(s: &str) -> Identity {
        Self::derive(s.as_bytes())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    // use test::Bencher;

    #[test]
    fn test_decrypt() {
        let mut rng = rand::thread_rng();

        let id = "email:w.geraedts@sarif.nl".as_bytes();
        let kid = Identity::derive(id);

        let m = Message::generate(&mut rng);

        let (pk, sk) = setup(32, &mut rng);
        let usk = extract(&pk, &sk, &kid, &mut rng);

        let c = encrypt(&pk, &kid, &m, &mut rng);
        let m2 = decrypt(&usk, &c).unwrap();

        assert_eq!(m, m2);
    }
}
