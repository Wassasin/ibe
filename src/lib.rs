#![no_std]

//! Identity Based Encryption Waters-Naccache scheme on the [BLS12-381 pairing-friendly elliptic curve](https://github.com/zkcrypto/bls12_381).
//!  * Inspired by: [CHARM implementation](https://github.com/JHUISI/charm/blob/dev/charm/schemes/ibenc/ibenc_waters05.py)
//!  * From: "[Secure and Practical Identity-Based Encryption](http://eprint.iacr.org/2005/369.pdf)"
//!  * Published in: IET Information Security, 2007
//!
//! Uses [SHA3-512](https://crates.io/crates/tiny-keccak) for hashing to identities.

mod util;
use crate::util::*;

use bls12_381::{G1Affine, G2Affine, G2Projective, Gt, Scalar};
use rand::Rng;

const HASH_BIT_LEN: usize = 512;
const HASH_BYTE_LEN: usize = HASH_BIT_LEN / 8;

const BITSIZE: usize = 32;
const CHUNKSIZE: usize = BITSIZE / 8;
const CHUNKS: usize = HASH_BYTE_LEN / CHUNKSIZE;

type Parameters = [Scalar; CHUNKS];

/// Public key parameters generated by the PKG used to encrypt messages.
#[derive(Clone, Copy)]
pub struct PublicKey {
    g: G1Affine,
    g1: G1Affine,
    g2: G2Affine,
    uprime: G2Affine,
    u: Parameters,
}

/// Field parameters for an identity.
///
/// Effectively a hash of an identity, mapped to the curve field.
/// Together with the public key parameters generated by the PKG forms the user public key.
#[derive(Clone, Copy, Debug)]
pub struct Identity([Scalar; CHUNKS]);

/// Secret key parameter generated by the PKG used to extract user private keys.
#[derive(Clone, Copy)]
pub struct SecretKey {
    g2prime: G2Affine,
}

/// Points on the paired curves that form the user private key.
#[derive(Clone, Copy)]
pub struct UserPrivateKey {
    d1: G2Affine,
    d2: G1Affine,
}

/// Encrypted message. Can only be decrypted with an user private key.
#[derive(Clone, Copy)]
pub struct CipherText {
    c1: Gt,
    c2: G1Affine,
    c3: G2Affine,
}

/// A point on the paired curve that can be encrypted and decrypted. Unmarshals to a key usable in AES.
#[derive(Clone, Copy, PartialEq, Debug)]
pub struct Message(Gt);

impl Message {
    /// Generate a random point on the paired curve.
    pub fn generate<R: Rng>(rng: &mut R) -> Self {
        Self(rand_gt(rng))
    }

    // /// Hashes the underlying point on the curve representation to a scalar.
    // pub fn marshal(&self) -> [u8; HASH_BYTE_LEN] {
    //     use util::Marshallable;

    //     let mut h = util::Sha3Write::new();
    //     self.0.marshal(&mut h);

    //     h.finalize()
    // }
}

/// Generate a keypair used by the Private Key Generator (PKG).
pub fn setup<R: Rng>(rng: &mut R) -> (PublicKey, SecretKey) {
    use core::ops::Mul;

    let g: G1Affine = rand_g1(rng).into();

    let alpha = rand_scalar(rng);
    let g1 = g.mul(alpha).into();

    let g2 = rand_g2(rng).into();
    let uprime = rand_g2(rng).into();

    let mut u = [Scalar::zero(); CHUNKS];
    for ui in u.iter_mut() {
        *ui = rand_scalar(rng);
    }

    let pk = PublicKey {
        g,
        g1,
        g2,
        uprime,
        u,
    };

    let g2prime: G2Affine = g2.mul(alpha).into();

    let sk = SecretKey { g2prime };

    (pk, sk)
}

/// Extract an user private key for a given identity.
pub fn extract<R: Rng>(
    pk: &PublicKey,
    sk: &SecretKey,
    v: &Identity,
    rng: &mut R,
) -> UserPrivateKey {
    use core::ops::{Add, Mul};

    let mut ucoll: G2Projective = pk.uprime.into();
    for (ui, vi) in pk.u.iter().zip(&v.0) {
        ucoll = ucoll.mul(pow_scalar(ui, vi));
    }

    let r = rand_scalar(rng);
    let d1 = sk.g2prime.add(ucoll.mul(r)).into();
    let d2 = pk.g.mul(r).into();

    UserPrivateKey { d1, d2 }
}

/// Encrypt a message using the PKG public key and an identity.
pub fn encrypt<R: Rng>(pk: &PublicKey, v: &Identity, m: &Message, rng: &mut R) -> CipherText {
    use core::ops::{Add, Mul};

    let t = rand_scalar(rng);

    let mut c3coll: G2Projective = pk.uprime.into();
    for (ui, vi) in pk.u.iter().zip(&v.0) {
        c3coll = c3coll.mul(pow_scalar(ui, vi));
    }

    let c1 = bls12_381::pairing(&pk.g1, &pk.g2).mul(t).add(m.0);
    let c2 = pk.g.mul(t).into();
    let c3 = c3coll.mul(t).into();

    CipherText { c1, c2, c3 }
}

/// Decrypt ciphertext to a message using a user private key.
pub fn decrypt(usk: &UserPrivateKey, c: &CipherText) -> Message {
    use core::ops::{Add, Sub};

    let num = bls12_381::pairing(&usk.d2, &c.c3);
    let dem = bls12_381::pairing(&c.c2, &usk.d1);

    let m = c.c1.add(num).sub(dem);
    Message(m)
}

impl Identity {
    /// Hash a byte slice to a set of Identity parameters, which acts as a user public key.
    /// Uses sha3-512 internally.
    pub fn derive(b: &[u8]) -> Identity {
        let hash = tiny_keccak::sha3_512(b);

        let mut result = [Scalar::zero(); CHUNKS];
        for (i, chunk) in hash.chunks_exact(CHUNKSIZE).enumerate() {
            use core::convert::TryInto;
            result[i] = u64::from(u32::from_le_bytes(chunk.try_into().unwrap())).into();
        }

        Identity(result)
    }

    /// Hash a string slice to a set of Identity parameters.
    /// Directly converts characters to UTF-8 byte representation.
    pub fn derive_str(s: &str) -> Identity {
        Self::derive(s.as_bytes())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const ID: &'static str = "email:w.geraedts@sarif.nl";

    #[test]
    fn encrypt_decrypt_eq() {
        let mut rng = rand::thread_rng();

        let id = ID.as_bytes();
        let kid = Identity::derive(id);

        let m = Message::generate(&mut rng);

        let (pk, sk) = setup(&mut rng);
        let usk = extract(&pk, &sk, &kid, &mut rng);

        let c = encrypt(&pk, &kid, &m, &mut rng);
        let m2 = decrypt(&usk, &c);

        assert_eq!(m, m2);
    }

    #[test]
    fn identity_stability() {
        const REFERENCE: &'static [u32; 16] = &[
            224058892, 3543031066, 2100894308, 1450993543, 380724969, 4144530249, 2749396120,
            320408521, 409248772, 2464563459, 877936958, 2596797041, 3979538376, 3505820338,
            590474010, 189115610,
        ];

        let id = ID.as_bytes();
        let kid = Identity::derive(id);

        for (kidi, ri) in kid.0.iter().zip(REFERENCE) {
            let mut buf = [0u8; 32];
            buf[0..4].copy_from_slice(&ri.to_le_bytes());

            assert_eq!(kidi.to_bytes(), buf);
        }
    }
}
