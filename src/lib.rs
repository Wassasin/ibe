#![no_std]

//! Identity Based Encryption Waters-Naccache scheme on the [BLS12-381 pairing-friendly elliptic curve](https://github.com/zkcrypto/bls12_381).
//!  * Inspired by: [CHARM implementation](https://github.com/JHUISI/charm/blob/dev/charm/schemes/ibenc/ibenc_waters05.py)
//!  * From: "[Secure and Practical Identity-Based Encryption](http://eprint.iacr.org/2005/369.pdf)"
//!  * Published in: IET Information Security, 2007
//!
//! Uses [SHA3-256](https://crates.io/crates/tiny-keccak) for hashing to identities.

// mod util;

use bls12_381::{G1Affine, G2Affine, G1Projective, G2Projective, Gt, Scalar};
// use pairing::{CurveProjective, Engine, Field, PrimeField};
use rand::Rng;
use byteorder::{ByteOrder, LittleEndian};

const HASH_BIT_LEN: usize = 256;
const HASH_BYTE_LEN: usize = HASH_BIT_LEN / 8;

const BITSIZE: usize = 32;
const CHUNKSIZE: usize = BITSIZE / 8;
const CHUNKS: usize = HASH_BYTE_LEN / CHUNKSIZE;

type Parameters = [Scalar; CHUNKS];

/// Public key parameters generated by the PKG used to encrypt messages.
#[derive(Clone, Copy)]
pub struct PublicKey {
    g: G1Affine,
    g1: G1Affine,
    g2: G2Affine,
    uprime: G2Affine,
    u: Parameters,
}

/// Field parameters for an identity.
///
/// Effectively a hash of an identity, mapped to the curve field.
/// Together with the public key parameters generated by the PKG forms the user public key.
#[derive(Clone, Copy, Debug)]
pub struct Identity([Scalar; CHUNKS]);

/// Secret key parameter generated by the PKG used to extract user private keys.
#[derive(Clone, Copy)]
pub struct SecretKey {
    g2prime: G2Affine,
}

/// Points on the paired curves that form the user private key.
#[derive(Clone, Copy)]
pub struct UserPrivateKey {
    d1: G2Affine,
    d2: G1Affine,
}

/// Encrypted message. Can only be decrypted with an user private key.
#[derive(Clone, Copy)]
pub struct CipherText {
    c1: Gt,
    c2: G1Affine,
    c3: G2Affine,
}

fn rand_scalar<R: ::rand::Rng>(rng: &mut R) -> Scalar {
    let mut buf = [0u8; 64];
    rng.fill_bytes(&mut buf);

    Scalar::from_bytes_wide(&buf)
}

fn rand_g1<R: ::rand::Rng>(rng: &mut R) -> G1Projective {
    use core::ops::Mul;
    let g = G1Projective::generator();
    let x = rand_scalar(rng);
    g.mul(x)
}

fn rand_g2<R: ::rand::Rng>(rng: &mut R) -> G2Projective {
    use core::ops::Mul;
    let g = G2Projective::generator();
    let x = rand_scalar(rng);
    g.mul(x)
}

fn rand_gt<R: ::rand::Rng>(rng: &mut R) -> Gt {
    let g1 = rand_g1(rng);
    let g2 = rand_g2(rng);
    bls12_381::pairing(&G1Affine::from(g1), &G2Affine::from(g2))
}

// TODO check implementation
fn pow_scalar(lhs: &Scalar, rhs: &Scalar) -> Scalar {
    let buf = rhs.to_bytes();
    let e = [
        LittleEndian::read_u64(&buf[0..8]),
        LittleEndian::read_u64(&buf[8..16]),
        LittleEndian::read_u64(&buf[16..24]),
        LittleEndian::read_u64(&buf[24..32]),
    ];

    lhs.pow(&e)
}

// /// A point on the paired curve that can be encrypted and decrypted. Unmarshals to a key usable in AES.
#[derive(Clone, Copy, PartialEq, Debug)]
pub struct Message(Gt);

impl Message {
    /// Generate a random point on the paired curve.
    pub fn generate<R: Rng>(rng: &mut R) -> Self {
        Self(rand_gt(rng))
    }

    // /// Hashes the underlying point on the curve representation to a scalar.
    // pub fn marshal(&self) -> [u8; HASH_BYTE_LEN] {
    //     use util::Marshallable;

    //     let mut h = util::Sha3Write::new();
    //     self.0.marshal(&mut h);

    //     h.finalize()
    // }
}

/// Generate a keypair used by the Private Key Generator (PKG).
pub fn setup<R: Rng>(l: usize, rng: &mut R) -> (PublicKey, SecretKey) {
    use core::ops::Mul;

    let h_len = HASH_BYTE_LEN * 8;
    let n = h_len / l;

    assert_eq!(CHUNKS, n);

    let g: G1Affine = rand_g1(rng).into();

    let alpha = rand_scalar(rng);
    let g1 = g.mul(alpha).into();

    let g2 = rand_g2(rng).into();
    let uprime = rand_g2(rng).into();

    let mut u = [Scalar::zero(); CHUNKS];
    for ui in u.iter_mut() {
        *ui = rand_scalar(rng);
    }

    let pk = PublicKey {
        g,
        g1,
        g2,
        uprime,
        u,
    };

    let g2prime: G2Affine = g2.mul(alpha).into();

    let sk = SecretKey { g2prime };

    (pk, sk)
}

/// Extract an user private key for a given identity.
pub fn extract<R: Rng>(
    pk: &PublicKey,
    sk: &SecretKey,
    v: &Identity,
    rng: &mut R,
) -> UserPrivateKey {
    use core::ops::{Add, Mul};

    let mut ucoll: G2Projective = pk.uprime.into();
    for (ui, vi) in pk.u.iter().zip(&v.0) {
        ucoll = ucoll.mul(pow_scalar(ui, vi));
    }

    let r = rand_scalar(rng);
    let d1 = sk.g2prime.add(ucoll.mul(r)).into();
    let d2 = pk.g.mul(r).into();

    UserPrivateKey { d1, d2 }
}

/// Encrypt a message using the PKG public key and an identity.
pub fn encrypt<R: Rng>(pk: &PublicKey, v: &Identity, m: &Message, rng: &mut R) -> CipherText {
    use core::ops::{Add, Mul};

    let t = rand_scalar(rng);

    let mut c3coll: G2Projective = pk.uprime.into();
    for (ui, vi) in pk.u.iter().zip(&v.0) {
        c3coll = c3coll.mul(pow_scalar(ui, vi));
    }

    let c1 = bls12_381::pairing(&pk.g1, &pk.g2).mul(t).add(m.0);
    let c2 = pk.g.mul(t).into();
    let c3 = c3coll.mul(t).into();

    CipherText { c1, c2, c3 }
}

/// Decrypt ciphertext to a message using a user private key.
pub fn decrypt(usk: &UserPrivateKey, c: &CipherText) -> Message {
    use core::ops::{Add, Sub};

    let num = bls12_381::pairing(&usk.d2, &c.c3);
    let dem = bls12_381::pairing(&c.c2, &usk.d1);

    let m = c.c1.add(num).sub(dem);
    Message(m)
}

impl Identity {
    /// Hash a byte slice to a set of Identity parameters, which acts as a user public key.
    /// Uses sha3-256 internally.
    pub fn derive(b: &[u8]) -> Identity {
        let hash = tiny_keccak::sha3_256(b);

        let mut result = [Scalar::zero(); CHUNKS];
        for (i, chunk) in hash.chunks_exact(CHUNKS).enumerate() {
            use core::convert::TryInto;
            result[i] = u64::from_le_bytes(chunk.try_into().unwrap()).into();
        }

        Identity(result)
    }

    /// Hash a string slice to a set of Identity parameters.
    /// Directly converts characters to UTF-8 byte representation.
    pub fn derive_str(s: &str) -> Identity {
        Self::derive(s.as_bytes())
    }
}

#[cfg(test)]
mod tests {
    extern crate std;
    use super::*;

    const ID: &'static str = "email:w.geraedts@sarif.nl";

    #[test]
    fn encrypt_decrypt_eq() {
        let mut rng = rand::thread_rng();

        let id = ID.as_bytes();
        let kid = Identity::derive(id);

        let m = Message::generate(&mut rng);

        let (pk, sk) = setup(32, &mut rng);
        let usk = extract(&pk, &sk, &kid, &mut rng);

        let c = encrypt(&pk, &kid, &m, &mut rng);
        let m2 = decrypt(&usk, &c);

        assert_eq!(m, m2);
    }

    // #[test]
    // fn identity_stability() {
    //     use std::eprintln;
    //     const REFERENCE: Identity = Identity([Fr(FrRepr([14203934459016671978, 8273609933914418952, 14014603559629590768, 7636334028375760790])), Fr(FrRepr([8799993730701008736, 6641523070592116114, 15664207911569855817, 3602475904748110484])), Fr(FrRepr([642564103857791219, 7985374078981486964, 6568666398051686446, 4051603964320429532])), Fr(FrRepr([16577230410371047587, 10825025205331962749, 2156706444940226086, 5240033946088233315])), Fr(FrRepr([0, 0, 0, 0])), Fr(FrRepr([0, 0, 0, 0])), Fr(FrRepr([0, 0, 0, 0])), Fr(FrRepr([0, 0, 0, 0]))]);

    //     let id = ID.as_bytes();
    //     let kid = Identity::derive(id);

    //     eprintln!("{:?}", kid);
    // }
}
