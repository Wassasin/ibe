//! Identity Based Encryption by Chen, Gay and Wee.
//!
//! The structure of the byte serialisation of the various datastructures is not guaranteed
//! to remain constant between releases of this library.
//! All operations in this library are implemented to run in constant time.

use crate::util::*;

use irmaseal_curve::{multi_miller_loop, pairing, G1Affine, G2Affine, G2Prepared, Gt, Scalar};
use rand::Rng;
use subtle::CtOption;

// Max identity buf size
const K: usize = 256;
const N: usize = 2 * K;
const N_BYTE_LEN: usize = N / 8;

// Sizes of elements in particular groups (compressed)
const GT_BYTES: usize = 288;
//const G1_BYTES: usize = 48;
//const G2_BYTES: usize = 96;
//const SCALAR_BYTES: usize = 32;
//
//// Derived sizes
//const PK_BYTES: usize = 6 * G1_BYTES + GT_BYTES;
//const SK_BYTES: usize = 12 * SCALAR_BYTES;
//const USK_BYTES: usize = 4 * G2_BYTES;
//const CT_BYTES: usize = 4 * G1_BYTES;

/// Public key parameters generated by the PKG used to encrypt messages.
/// Also known as MPK.
#[derive(Clone, Copy, PartialEq)]
pub struct PublicKey {
    a_1: [G1Affine; 2],
    w0ta_1: [G1Affine; 2],
    w1ta_1: [G1Affine; 2],
    kta_t: Gt,
}

/// Secret key parameter generated by the PKG used to extract user secret keys.
/// Also known as MSK.
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct SecretKey {
    b: [Scalar; 2],
    k: [Scalar; 2],
    w0: [[Scalar; 2]; 2],
    w1: [[Scalar; 2]; 2],
}

/// User secret key. Can be used to decrypt the corresponding ciphertext.
/// Also known as USK_{id}.
#[derive(Clone, Copy, PartialEq, Debug)]
pub struct UserSecretKey {
    d0: [G2Affine; 2],
    d1: [G2Affine; 2],
}

/// Encrypted message. Can only be decrypted with a corresponding user secret key.
/// Also known as CT_{id}
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CipherText {
    c0: [G1Affine; 2],
    c1: [G1Affine; 2],
}

/// Hashed byte representation of an identity.
pub struct Identity([u8; N_BYTE_LEN]);

/// A shared secret in the target group.
///
/// You can use the byte representation to derive, for example, an AES key.
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct SharedSecret(Gt);

/// Generate a keypair used by the Private Key Generator (PKG).
pub fn setup<R: Rng>(rng: &mut R) -> (PublicKey, SecretKey) {
    let g1 = G1Affine::generator();
    let g2 = G2Affine::generator();

    let a = [rand_scalar(rng), rand_scalar(rng)];
    let b = [rand_scalar(rng), rand_scalar(rng)];

    let w0 = [
        [rand_scalar(rng), rand_scalar(rng)],
        [rand_scalar(rng), rand_scalar(rng)],
    ];

    let w1 = [
        [rand_scalar(rng), rand_scalar(rng)],
        [rand_scalar(rng), rand_scalar(rng)],
    ];

    let k = [rand_scalar(rng), rand_scalar(rng)];

    let w0ta = [
        w0[0][0] * a[0] + w0[1][0] * a[1],
        w0[0][1] * a[0] + w0[1][1] * a[1],
    ];
    let w1ta = [
        w1[0][0] * a[0] + w1[1][0] * a[1],
        w1[0][1] * a[0] + w1[1][1] * a[1],
    ];

    let a_1 = [(g1 * a[0]).into(), (g1 * a[1]).into()];
    let w0ta_1 = [(g1 * w0ta[0]).into(), (g1 * w0ta[1]).into()];
    let w1ta_1 = [(g1 * w1ta[0]).into(), (g1 * w1ta[1]).into()];
    let kta_t = pairing(&g1, &g2) * (k[0] * a[0] + k[1] * a[1]);

    (
        PublicKey {
            a_1,
            w0ta_1,
            w1ta_1,
            kta_t,
        },
        SecretKey { b, k, w0, w1 },
    )
}

/// Extract a user secret key for a given identity.
pub fn extract_usk<R: Rng>(sk: &SecretKey, v: &Identity, rng: &mut R) -> UserSecretKey {
    let g2 = G2Affine::generator();
    let r = rand_scalar(rng);

    let br = [sk.b[0] * r, sk.b[1] * r];

    // X = W0 + id W1
    let id = v.to_scalar();
    let x = [
        [
            id * sk.w1[0][0] + sk.w0[0][0],
            id * sk.w1[0][1] + sk.w0[0][1],
        ],
        [
            id * sk.w1[1][0] + sk.w0[1][0],
            id * sk.w1[1][1] + sk.w0[1][1],
        ],
    ];

    let xbrplusk = [
        x[0][0] * br[0] + x[0][1] * br[1] + sk.k[0],
        x[1][0] * br[0] + x[1][1] * br[1] + sk.k[1],
    ];

    let d0: [G2Affine; 2] = [(g2 * br[0]).into(), (g2 * br[1]).into()];
    let d1: [G2Affine; 2] = [(g2 * xbrplusk[0]).into(), (g2 * xbrplusk[1]).into()];

    UserSecretKey { d0, d1 }
}

/// Generate a symmetric key and corresponding CipherText for that key.
pub fn encrypt<R: Rng>(pk: &PublicKey, v: &Identity, rng: &mut R) -> (CipherText, SharedSecret) {
    let s = rand_scalar(rng);
    let id = v.to_scalar();

    let c0: [G1Affine; 2] = [(pk.a_1[0] * s).into(), (pk.a_1[1] * s).into()];
    let c1: [G1Affine; 2] = [
        ((pk.w0ta_1[0] * s) + (pk.w1ta_1[0] * (s * id))).into(),
        ((pk.w0ta_1[1] * s) + (pk.w1ta_1[1] * (s * id))).into(),
    ];

    let cprime = pk.kta_t * s;

    (CipherText { c0, c1 }, SharedSecret(cprime))
}

/// Decrypt ciphertext to a SymmetricKey using a user secret key.
pub fn decrypt(usk: &UserSecretKey, ct: &CipherText) -> SharedSecret {
    let m = multi_miller_loop(&[
        (&ct.c0[0], &G2Prepared::from(usk.d1[0])),
        (&ct.c0[1], &G2Prepared::from(usk.d1[1])),
        (&-ct.c1[0], &G2Prepared::from(usk.d0[0])),
        (&-ct.c1[1], &G2Prepared::from(usk.d0[1])),
    ])
    .final_exponentiation();

    SharedSecret(m)
}

impl Identity {
    /// Hash a byte slice to a set of Identity parameters, which acts as a user public key.
    /// Uses sha3-512 internally.
    pub fn derive(b: &[u8]) -> Identity {
        Identity(sha3_512(b))
    }

    /// Hash a string slice to a set of Identity parameters.
    /// Directly converts characters to UTF-8 byte representation.
    pub fn derive_str(s: &str) -> Identity {
        Self::derive(s.as_bytes())
    }

    fn to_scalar(&self) -> Scalar {
        Scalar::from_bytes_wide(&self.0)
    }
}

impl Clone for Identity {
    fn clone(&self) -> Self {
        let mut res = [u8::default(); N_BYTE_LEN];
        for (src, dst) in self.0.iter().zip(res.as_mut().iter_mut()) {
            *dst = *src;
        }
        Identity(res)
    }
}

impl Copy for Identity {}

impl SharedSecret {
    pub fn to_bytes(&self) -> [u8; GT_BYTES] {
        self.0.to_compressed()
    }

    pub fn from_bytes(bytes: &[u8; GT_BYTES]) -> CtOption<Self> {
        Gt::from_compressed(bytes).map(Self)
    }
}

/*
impl PublicKey {
    pub fn to_bytes(&self) -> [u8; PK_BYTES] {}

    pub fn from_bytes(bytes: &[u8; PK_BYTES]) -> CtOption<Self> {}
}

impl SecretKey {
    pub fn to_bytes(&self) -> [u8; SK_BYTES] {}

    pub fn from_bytes(bytes: &[u8; SK_BYTES]) -> CtOption<Self> {}
}

impl UserSecretKey {
    pub fn to_bytes(&self) -> [u8; USK_BYTES] {
        let mut res = [0u8; USK_BYTES];
        res
    }

    pub fn from_bytes(bytes: &[u8; USK_BYTES]) -> CtOption<Self> {}
}

impl CipherText {
    pub fn to_bytes(&self) -> [u8; CT_BYTES] {
        let mut res = [0u8; CT_BYTES];
        res
    }

    pub fn from_bytes(bytes: &[u8; CT_BYTES]) -> CtOption<Self> {}
}
*/

#[cfg(test)]
mod tests {
    use super::*;

    const ID: &'static [u8] = b"email:w.geraedts@sarif.nl";

    #[allow(dead_code)]
    struct DefaultSubResults {
        pk: PublicKey,
        sk: SecretKey,
        usk: UserSecretKey,
        c: CipherText,
        ss: SharedSecret,
    }

    fn perform_default() -> DefaultSubResults {
        let mut rng = rand::thread_rng();

        let kid = Identity::derive(ID);

        let (pk, sk) = setup(&mut rng);
        let usk = extract_usk(&sk, &kid, &mut rng);

        let (c, ss) = encrypt(&pk, &kid, &mut rng);

        DefaultSubResults { pk, sk, usk, c, ss }
    }

    #[test]
    fn eq_encrypt_decrypt() {
        let results = perform_default();
        let ss2 = decrypt(&results.usk, &results.c);

        assert_eq!(results.ss, ss2);
    }
    //    #[test]
    //    fn eq_serialize_deserialize() {
    //        let result = perform_default();
    //
    //        assert_eq!(
    //            result.ss,
    //            SharedSecret::from_bytes(&result.ss.to_bytes()).unwrap()
    //        );
    //        assert!(result.pk == PublicKey::from_bytes(&result.pk.to_bytes()).unwrap());
    //        assert_eq!(
    //            result.sk,
    //            SecretKey::from_bytes(&result.sk.to_bytes()).unwrap()
    //        );
    //        assert_eq!(
    //            result.usk,
    //            UserSecretKey::from_bytes(&result.usk.to_bytes()).unwrap()
    //        );
    //        assert_eq!(
    //            result.c,
    //            CipherText::from_bytes(&result.c.to_bytes()).unwrap()
    //        );
    //    }
}
