//! Identity Based Encryption Boyens & Waters scheme.
//! Uses [SHA3-512](https://crates.io/crates/tiny-keccak) for hashing to identities.
//!
//! The structure of the byte serialisation of the various datastructures is not guaranteed
//! to remain constant between releases of this library.
//! All operations in this library are implemented to run in constant time.

use crate::util::*;
use arrayref::{array_mut_ref, array_ref, array_refs, mut_array_refs};
use irmaseal_curve::{pairing, G1Affine, G1Projective, G2Affine, G2Projective, Gt, Scalar};
use rand::Rng;
use subtle::{Choice, ConditionallySelectable, CtOption};

const K: usize = 256;
const N: usize = 2 * K;
const N_BYTE_LEN: usize = N / 8;

const G1_SIZE: usize = 48;
const G2_SIZE: usize = 96;
const GT_SIZE: usize = 288;
const SCALAR_SIZE: usize = 32;

const HASH1_PARAMETER_SIZE: usize = N * G1_SIZE;
const HASH2_PARAMETER_SIZE: usize = N * G2_SIZE;

const PUBLICKEYSIZE: usize =
    5 * G1_SIZE + G2_SIZE + GT_SIZE + HASH1_PARAMETER_SIZE + HASH2_PARAMETER_SIZE;
const SECRETKEYSIZE: usize = 5 * SCALAR_SIZE;
const USERSECRETKEYSIZE: usize = 5 * G2_SIZE;
const CIPHERTEXTSIZE: usize = GT_SIZE + 5 * G1_SIZE;

struct Hash1Parameters([G1Affine; N]);
struct Hash2Parameters([G2Affine; N]);

/// Public key parameters generated by the PKG used to encrypt messages.
#[derive(Clone, Copy, PartialEq)]
pub struct PublicKey {
    omega: Gt,
    g: G1Affine,
    h: G2Affine,
    gs: Hash1Parameters,
    hs: Hash2Parameters,
    v1: G1Affine,
    v2: G1Affine,
    v3: G1Affine,
    v4: G1Affine,
}

/// Secret key parameter generated by the PKG used to extract user secret keys.
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct SecretKey {
    alpha: Scalar,
    t1: Scalar,
    t2: Scalar,
    t3: Scalar,
    t4: Scalar,
}

/// Points on the paired curves that form the user secret key.
#[derive(Clone, Copy, PartialEq, Debug)]
pub struct UserSecretKey {
    d0: G2Affine,
    d1: G2Affine,
    d2: G2Affine,
    d3: G2Affine,
    d4: G2Affine,
}

/// Byte representation of an identity.
///
/// Can be hashed to the curve together with some parameters from the Public Key.
pub struct Identity([u8; N_BYTE_LEN]);

/// Encrypted message. Can only be decrypted with an user secret key.
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CipherText {
    cprime: Gt,
    c0: G1Affine,
    c1: G1Affine,
    c2: G1Affine,
    c3: G1Affine,
    c4: G1Affine,
}

/// A point on the paired curve that can be encrypted and decrypted.
///
/// You can use the byte representation to derive an AES key.
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct SymmetricKey(Gt);

/// Generate a keypair used by the Private Key Generator (PKG).
pub fn setup<R: Rng>(rng: &mut R) -> (PublicKey, SecretKey) {
    let g: G1Affine = rand_g1(rng).into();
    let h: G2Affine = rand_g2(rng).into();

    let alpha = rand_scalar(rng);

    let t1 = rand_scalar(rng);
    let t2 = rand_scalar(rng);
    let t3 = rand_scalar(rng);
    let t4 = rand_scalar(rng);

    let omega: Gt = pairing(&g, &h) * (t1 * t2 * alpha);

    let v1: G1Affine = (g * t1).into();
    let v2: G1Affine = (g * t2).into();
    let v3: G1Affine = (g * t3).into();
    let v4: G1Affine = (g * t4).into();

    let mut gs = Hash1Parameters([G1Affine::default(); N]);
    let mut hs = Hash2Parameters([G2Affine::default(); N]);

    for (gi, hi) in gs.0.iter_mut().zip(hs.0.iter_mut()) {
        let zi = rand_scalar(rng);
        *gi = (g * zi).into();
        *hi = (h * zi).into();
    }

    (
        PublicKey {
            omega,
            g,
            h,
            gs,
            hs,
            v1,
            v2,
            v3,
            v4,
        },
        SecretKey {
            alpha,
            t1,
            t2,
            t3,
            t4,
        },
    )
}

fn hash_to_g(pk: &PublicKey, v: &Identity) -> G1Projective {
    let mut hcoll: G1Projective = pk.g.into();
    for (hi, vi) in pk.gs.0.iter().zip(bits(&v.0)) {
        hcoll = G1Projective::conditional_select(&hcoll, &(hi + hcoll), vi);
    }
    hcoll
}

fn hash_to_h(pk: &PublicKey, v: &Identity) -> G2Projective {
    let mut hcoll: G2Projective = pk.h.into();
    for (hi, vi) in pk.hs.0.iter().zip(bits(&v.0)) {
        hcoll = G2Projective::conditional_select(&hcoll, &(hi + hcoll), vi);
    }
    hcoll
}

/// Extract an user secret key for a given identity.
pub fn extract_usk<R: Rng>(
    pk: &PublicKey,
    sk: &SecretKey,
    v: &Identity,
    rng: &mut R,
) -> UserSecretKey {
    let r1 = rand_scalar(rng);
    let r2 = rand_scalar(rng);

    let d0: G2Affine = (pk.h * (r1 * sk.t1 * sk.t2 + r2 * sk.t3 * sk.t4)).into();
    let d1: G2Affine = (pk.h * (-sk.alpha * sk.t2) + hash_to_h(pk, v) * (-r1 * sk.t2)).into();
    let d2: G2Affine = (pk.h * (-sk.alpha * sk.t1) + hash_to_h(pk, v) * (-r1 * sk.t1)).into();
    let d3: G2Affine = (hash_to_h(pk, v) * (-r2 * sk.t4)).into();
    let d4: G2Affine = (hash_to_h(pk, v) * (-r2 * sk.t3)).into();

    UserSecretKey { d0, d1, d2, d3, d4 }
}

/// Generate a symmetric key and corresponding CipherText for that key.
pub fn encrypt<R: Rng>(pk: &PublicKey, v: &Identity, rng: &mut R) -> (CipherText, SymmetricKey) {
    let s = rand_scalar(rng);
    let s1 = rand_scalar(rng);
    let s2 = rand_scalar(rng);

    let ss = rand_gt(rng).into();

    let cprime = (pk.omega * s) * ss;

    let c0: G1Affine = (hash_to_g(pk, v) * s).into();
    let c1: G1Affine = (pk.v1 * (s - s1)).into();
    let c2: G1Affine = (pk.v2 * s1).into();
    let c3: G1Affine = (pk.v3 * (s - s2)).into();
    let c4: G1Affine = (pk.v4 * s2).into();

    (
        CipherText {
            cprime,
            c0,
            c1,
            c2,
            c3,
            c4,
        },
        SymmetricKey(ss),
    )
}

/// Decrypt ciphertext to a SymmetricKey using a user secret key.
pub fn decrypt(usk: &UserSecretKey, c: &CipherText) -> SymmetricKey {
    let m = c.cprime
        * pairing(&c.c0, &usk.d0)
        * pairing(&c.c1, &usk.d1)
        * pairing(&c.c2, &usk.d2)
        * pairing(&c.c3, &usk.d3)
        * pairing(&c.c4, &usk.d4);

    SymmetricKey(m)
}

impl Identity {
    /// Hash a byte slice to a set of Identity parameters, which acts as a user public key.
    /// Uses sha3-512 internally.
    pub fn derive(b: &[u8]) -> Identity {
        Identity(sha3_512(b))
    }

    /// Hash a string slice to a set of Identity parameters.
    /// Directly converts characters to UTF-8 byte representation.
    pub fn derive_str(s: &str) -> Identity {
        Self::derive(s.as_bytes())
    }
}

impl Clone for Identity {
    fn clone(&self) -> Self {
        let mut res = [u8::default(); N_BYTE_LEN];
        for (src, dst) in self.0.iter().zip(res.as_mut().iter_mut()) {
            *dst = *src;
        }
        Identity(res)
    }
}

impl Copy for Identity {}

impl SymmetricKey {
    pub fn to_bytes(&self) -> [u8; GT_SIZE] {
        self.0.to_compressed()
    }

    pub fn from_bytes(bytes: &[u8; GT_SIZE]) -> CtOption<Self> {
        Gt::from_compressed(bytes).map(Self)
    }
}

impl Hash1Parameters {
    pub fn to_bytes(&self) -> [u8; HASH1_PARAMETER_SIZE] {
        let mut res = [0u8; HASH1_PARAMETER_SIZE];
        for i in 0..N {
            *array_mut_ref![&mut res, i * 48, 48] = self.0[i].to_compressed();
        }
        res
    }

    pub fn from_bytes(bytes: &[u8; HASH1_PARAMETER_SIZE]) -> CtOption<Self> {
        let mut res = [G1Affine::default(); N];
        let mut is_some = Choice::from(1u8);
        for i in 0..N {
            // See comment in PublicKey::from_bytes on cofactor.
            is_some &= G1Affine::from_compressed_unchecked(array_ref![bytes, i * 48, 48])
                .map(|s| {
                    res[i] = s;
                })
                .is_some();
        }
        CtOption::new(Hash1Parameters(res), is_some)
    }
}

impl ConditionallySelectable for Hash1Parameters {
    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
        let mut res = [G1Affine::default(); N];
        for (i, (ai, bi)) in a.0.iter().zip(b.0.iter()).enumerate() {
            res[i] = G1Affine::conditional_select(&ai, &bi, choice);
        }
        Hash1Parameters(res)
    }
}

impl PartialEq for Hash1Parameters {
    fn eq(&self, rhs: &Hash1Parameters) -> bool {
        self.0.iter().zip(rhs.0.iter()).all(|(x, y)| x.eq(y))
    }
}

impl Clone for Hash1Parameters {
    fn clone(&self) -> Self {
        let mut res = [G1Affine::default(); N];
        for (src, dst) in self.0.iter().zip(res.as_mut().iter_mut()) {
            *dst = *src;
        }
        Self(res)
    }
}

impl Copy for Hash1Parameters {}

impl Default for Hash1Parameters {
    fn default() -> Self {
        Hash1Parameters([G1Affine::default(); N])
    }
}

impl Hash2Parameters {
    pub fn to_bytes(&self) -> [u8; HASH2_PARAMETER_SIZE] {
        let mut res = [0u8; HASH2_PARAMETER_SIZE];
        for i in 0..N {
            *array_mut_ref![&mut res, i * 96, 96] = self.0[i].to_compressed();
        }
        res
    }

    pub fn from_bytes(bytes: &[u8; HASH2_PARAMETER_SIZE]) -> CtOption<Self> {
        let mut res = [G2Affine::default(); N];
        let mut is_some = Choice::from(1u8);
        for i in 0..N {
            // See comment in PublicKey::from_bytes on cofactor.
            is_some &= G2Affine::from_compressed_unchecked(array_ref![bytes, i * 96, 96])
                .map(|s| {
                    res[i] = s;
                })
                .is_some();
        }
        CtOption::new(Hash2Parameters(res), is_some)
    }
}

impl ConditionallySelectable for Hash2Parameters {
    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
        let mut res = [G2Affine::default(); N];
        for (i, (ai, bi)) in a.0.iter().zip(b.0.iter()).enumerate() {
            res[i] = G2Affine::conditional_select(&ai, &bi, choice);
        }
        Hash2Parameters(res)
    }
}

impl PartialEq for Hash2Parameters {
    fn eq(&self, rhs: &Hash2Parameters) -> bool {
        self.0.iter().zip(rhs.0.iter()).all(|(x, y)| x.eq(y))
    }
}

impl Clone for Hash2Parameters {
    fn clone(&self) -> Self {
        let mut res = [G2Affine::default(); N];
        for (src, dst) in self.0.iter().zip(res.as_mut().iter_mut()) {
            *dst = *src;
        }
        Self(res)
    }
}

impl Copy for Hash2Parameters {}

impl Default for Hash2Parameters {
    fn default() -> Self {
        Hash2Parameters([G2Affine::default(); N])
    }
}

impl PublicKey {
    pub fn to_bytes(&self) -> [u8; PUBLICKEYSIZE] {
        let mut res = [0u8; PUBLICKEYSIZE];
        let (omega, g, h, gs, hs, v1, v2, v3, v4) = mut_array_refs![
            &mut res,
            GT_SIZE,
            G1_SIZE,
            G2_SIZE,
            HASH1_PARAMETER_SIZE,
            HASH2_PARAMETER_SIZE,
            G1_SIZE,
            G1_SIZE,
            G1_SIZE,
            G1_SIZE
        ];

        *omega = self.omega.to_compressed();
        *g = self.g.to_compressed();
        *h = self.h.to_compressed();
        *gs = self.gs.to_bytes();
        *hs = self.hs.to_bytes();

        *v1 = self.v1.to_compressed();
        *v2 = self.v2.to_compressed();
        *v3 = self.v3.to_compressed();
        *v4 = self.v4.to_compressed();

        res
    }

    pub fn from_bytes(bytes: &[u8; PUBLICKEYSIZE]) -> CtOption<Self> {
        let (omega, g, h, gs, hs, v1, v2, v3, v4) = array_refs![
            bytes,
            GT_SIZE,
            G1_SIZE,
            G2_SIZE,
            HASH1_PARAMETER_SIZE,
            HASH2_PARAMETER_SIZE,
            G1_SIZE,
            G1_SIZE,
            G1_SIZE,
            G1_SIZE
        ];

        // from_compressed_unchecked doesn't check whether the element has
        // a cofactor.  To mount an attack using a cofactor an attacker
        // must be able to manipulate the public parameters.  But then the
        // attacker can simply use parameters they generated themselves.
        // Thus checking for a cofactor is superfluous.

        let omega = Gt::from_compressed_unchecked(omega);
        let g = G1Affine::from_compressed_unchecked(g);
        let h = G2Affine::from_compressed_unchecked(h);
        let gs = Hash1Parameters::from_bytes(gs);
        let hs = Hash2Parameters::from_bytes(hs);
        let v1 = G1Affine::from_compressed_unchecked(v1);
        let v2 = G1Affine::from_compressed_unchecked(v2);
        let v3 = G1Affine::from_compressed_unchecked(v3);
        let v4 = G1Affine::from_compressed_unchecked(v4);

        omega.and_then(|omega| {
            g.and_then(|g| {
                h.and_then(|h| {
                    gs.and_then(|gs| {
                        hs.and_then(|hs| {
                            v1.and_then(|v1| {
                                v2.and_then(|v2| {
                                    v3.and_then(|v3| {
                                        v4.map(|v4| PublicKey {
                                            omega,
                                            g,
                                            h,
                                            gs,
                                            hs,
                                            v1,
                                            v2,
                                            v3,
                                            v4,
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            })
        })
    }
}

impl SecretKey {
    pub fn to_bytes(&self) -> [u8; SECRETKEYSIZE] {
        let mut res = [0u8; SECRETKEYSIZE];
        let (alpha, t1, t2, t3, t4) = mut_array_refs![
            &mut res,
            SCALAR_SIZE,
            SCALAR_SIZE,
            SCALAR_SIZE,
            SCALAR_SIZE,
            SCALAR_SIZE
        ];

        *alpha = self.alpha.to_bytes();
        *t1 = self.t1.to_bytes();
        *t2 = self.t2.to_bytes();
        *t3 = self.t3.to_bytes();
        *t4 = self.t4.to_bytes();

        res
    }

    pub fn from_bytes(bytes: &[u8; SECRETKEYSIZE]) -> CtOption<Self> {
        let (alpha, t1, t2, t3, t4) = array_refs![
            bytes,
            SCALAR_SIZE,
            SCALAR_SIZE,
            SCALAR_SIZE,
            SCALAR_SIZE,
            SCALAR_SIZE
        ];

        let alpha = Scalar::from_bytes(alpha);
        let t1 = Scalar::from_bytes(t1);
        let t2 = Scalar::from_bytes(t2);
        let t3 = Scalar::from_bytes(t3);
        let t4 = Scalar::from_bytes(t4);

        alpha.and_then(|alpha| {
            t1.and_then(|t1| {
                t2.and_then(|t2| {
                    t3.and_then(|t3| {
                        t4.map(|t4| SecretKey {
                            alpha,
                            t1,
                            t2,
                            t3,
                            t4,
                        })
                    })
                })
            })
        })
    }
}

impl UserSecretKey {
    pub fn to_bytes(&self) -> [u8; USERSECRETKEYSIZE] {
        let mut res = [0u8; USERSECRETKEYSIZE];
        let (d0, d1, d2, d3, d4) =
            mut_array_refs![&mut res, G2_SIZE, G2_SIZE, G2_SIZE, G2_SIZE, G2_SIZE];

        *d0 = self.d0.to_compressed();
        *d1 = self.d1.to_compressed();
        *d2 = self.d2.to_compressed();
        *d3 = self.d3.to_compressed();
        *d4 = self.d4.to_compressed();

        res
    }

    pub fn from_bytes(bytes: &[u8; USERSECRETKEYSIZE]) -> CtOption<Self> {
        let (d0, d1, d2, d3, d4) = array_refs![bytes, G2_SIZE, G2_SIZE, G2_SIZE, G2_SIZE, G2_SIZE];

        let d0 = G2Affine::from_compressed(d0);
        let d1 = G2Affine::from_compressed(d1);
        let d2 = G2Affine::from_compressed(d2);
        let d3 = G2Affine::from_compressed(d3);
        let d4 = G2Affine::from_compressed(d4);

        d0.and_then(|d0| {
            d1.and_then(|d1| {
                d2.and_then(|d2| {
                    d3.and_then(|d3| d4.map(|d4| UserSecretKey { d0, d1, d2, d3, d4 }))
                })
            })
        })
    }
}

impl CipherText {
    pub fn to_bytes(&self) -> [u8; CIPHERTEXTSIZE] {
        let mut res = [0u8; CIPHERTEXTSIZE];
        let (cprime, c0, c1, c2, c3, c4) =
            mut_array_refs![&mut res, GT_SIZE, G1_SIZE, G1_SIZE, G1_SIZE, G1_SIZE, G1_SIZE];

        *cprime = self.cprime.to_compressed();
        *c0 = self.c0.to_compressed();
        *c1 = self.c1.to_compressed();
        *c2 = self.c2.to_compressed();
        *c3 = self.c3.to_compressed();
        *c4 = self.c4.to_compressed();

        res
    }

    pub fn from_bytes(bytes: &[u8; CIPHERTEXTSIZE]) -> CtOption<Self> {
        let (cprime, c0, c1, c2, c3, c4) =
            array_refs![bytes, GT_SIZE, G1_SIZE, G1_SIZE, G1_SIZE, G1_SIZE, G1_SIZE];

        let cprime = Gt::from_compressed(cprime);
        let c0 = G1Affine::from_compressed(c0);
        let c1 = G1Affine::from_compressed(c1);
        let c2 = G1Affine::from_compressed(c2);
        let c3 = G1Affine::from_compressed(c3);
        let c4 = G1Affine::from_compressed(c4);

        cprime.and_then(|cprime| {
            c0.and_then(|c0| {
                c1.and_then(|c1| {
                    c2.and_then(|c2| {
                        c3.and_then(|c3| {
                            c4.map(|c4| CipherText {
                                cprime,
                                c0,
                                c1,
                                c2,
                                c3,
                                c4,
                            })
                        })
                    })
                })
            })
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const ID: &'static str = "email:w.geraedts@sarif.nl";

    #[allow(dead_code)]
    struct DefaultSubResults {
        kid: Identity,
        pk: PublicKey,
        sk: SecretKey,
        usk: UserSecretKey,
        c: CipherText,
        k: SymmetricKey,
    }

    fn perform_default() -> DefaultSubResults {
        let mut rng = rand::thread_rng();

        let id = ID.as_bytes();
        let kid = Identity::derive(id);

        let (pk, sk) = setup(&mut rng);
        let usk = extract_usk(&pk, &sk, &kid, &mut rng);

        let (c, k) = encrypt(&pk, &kid, &mut rng);

        DefaultSubResults {
            kid,
            pk,
            sk,
            usk,
            c,
            k,
        }
    }

    #[test]
    fn eq_encrypt_decrypt() {
        let results = perform_default();
        let k2 = decrypt(&results.usk, &results.c);

        assert_eq!(results.k, k2);
    }

    #[test]
    fn eq_serialize_deserialize() {
        let result = perform_default();

        assert_eq!(
            result.k,
            SymmetricKey::from_bytes(&result.k.to_bytes()).unwrap()
        );
        assert!(result.pk == PublicKey::from_bytes(&result.pk.to_bytes()).unwrap());
        assert_eq!(
            result.sk,
            SecretKey::from_bytes(&result.sk.to_bytes()).unwrap()
        );
        assert_eq!(
            result.usk,
            UserSecretKey::from_bytes(&result.usk.to_bytes()).unwrap()
        );
        assert_eq!(
            result.c,
            CipherText::from_bytes(&result.c.to_bytes()).unwrap()
        );
    }
}
